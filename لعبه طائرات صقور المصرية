<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØµÙ‚ÙˆØ± Ø§Ù„Ø¬Ùˆ Ø§Ù„Ù…ØµØ±ÙŠ ÙˆÙ…Ù‡Ù…Ø© Ø§Ù„ØªØ­Ø±ÙŠØ±</title>
    <!-- ØªØ¶Ù…ÙŠÙ† Ù…ÙƒØªØ¨Ø© Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Cairo', sans-serif;
            background-color: #0d1117; 
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            padding: 1rem;
        }
        #gameCanvas {
            background-color: #0b1a38; 
            border: 5px solid #eab308; /* Ø¥Ø·Ø§Ø± Ø°Ù‡Ø¨ÙŠ Ù…ØµØ±ÙŠ */
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(234, 179, 8, 0.7);
            touch-action: none; 
            position: relative;
        }
        .control-panel {
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #ef4444; 
        }
        .styled-button {
            padding: 0.75rem 1.5rem;
            font-weight: 800;
            border-radius: 9999px;
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }
        .styled-button:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(17, 24, 39, 0.98);
            border: 4px solid #facc15; 
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            max-width: 90%;
            width: 350px;
        }
        .char-icon {
            font-size: 35px;
            line-height: 1;
            transition: transform 0.2s;
            background-color: #374151;
            border-radius: 8px;
            padding: 0.5rem;
            border: 2px solid transparent;
        }
        .char-icon.selected {
            border: 4px solid #facc15;
            background-color: #4b5563;
        }
        #sky-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: -1;
        }
        .star {
            position: absolute;
            background-color: #ffffff;
            border-radius: 50%;
            opacity: 0.8;
            animation: move-sky linear infinite;
        }
        @keyframes move-sky {
            from { transform: translateY(0); }
            to { transform: translateY(600px); } 
        }
        .boss-active #gameCanvas {
            box-shadow: 0 0 40px 10px rgba(255, 0, 0, 0.8), 0 0 30px rgba(234, 179, 8, 0.7);
        }
        /* ØªØµÙ…ÙŠÙ… Ù…Ø¤Ø´Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø§Ø±Ø² */
        #audioLoading {
            background-color: #2563eb;
            color: #ffffff;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1.1rem;
            box-shadow: 0 0 15px rgba(37, 99, 235, 0.8);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body onload="initializeGame()">

    <div id="game-container" class="w-full max-w-xl">
        
        <header class="control-panel text-center mb-4 flex justify-between items-center">
            <div class="text-xl font-bold">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreDisplay" class="text-yellow-400">0</span></div>
            <div class="text-xl font-bold">Ø§Ù„Ø­ÙŠØ§Ø©: <span id="healthDisplay" class="text-red-400">3</span></div>
        </header>

        <div class="relative mx-auto block">
            <div id="sky-background"></div>
            <canvas id="gameCanvas" width="400" height="600"></canvas>
            
            <!-- Ù…Ø¤Ø´Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ -->
            <div id="audioLoading" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 hidden">
                Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø®Ø·Ø§Ø¨ Ø§Ù„Ù‚ÙŠØ§Ø¯Ø©...
            </div>
        </div>

        <!-- Ø±Ø³Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø´Ø®ØµÙŠØ© -->
        <div id="startScreen" class="message-box w-11/12 max-w-sm">
            <h2 class="text-3xl font-black mb-4 text-cyan-400">ØµÙ‚ÙˆØ± Ø§Ù„Ø¬Ùˆ Ø§Ù„Ù…ØµØ±ÙŠ ğŸ‡ªğŸ‡¬</h2>
            <h3 class="text-xl font-extrabold mb-4 text-yellow-400">Ù…Ù‡Ù…Ø© ØªØ­Ø±ÙŠØ± Ø§Ù„Ø£Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</h3>
            
            <!-- ØªØ­ÙŠØ© Ù…Ø­Ù…Ø¯ ØµØ¨Ø±ÙŠ -->
            <p class="text-sm text-gray-500 mb-6 border-t border-gray-700 pt-3">
                Ù…Ø¹ ØªØ­ÙŠØ§ØªÙŠ: Ù…Ø­Ù…Ø¯ ØµØ¨Ø±ÙŠ Ø§Ù„Ø´Ø±Ù‚Ø§ÙˆÙŠ.
            </p>
            
            <p class="mb-6 text-gray-300">Ø§Ø®ØªØ± Ø·Ø§Ø¦Ø±ØªÙƒ/Ù‚Ø§Ø¦Ø¯Ùƒ Ù„Ù„Ø§Ù†Ø·Ù„Ø§Ù‚:</p>
            
            <div id="char-selection" class="flex justify-around mb-6">
                <!-- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù‚Ø§Ø¦Ø¯ Ø§Ù„Ø³ÙŠØ³ÙŠ -->
                <button data-char="Ø§Ù„Ø³ÙŠØ³ÙŠ" data-emoji="â­" class="char-icon hover:scale-110 transition p-2 rounded-lg">â­</button>
                <button data-char="Omar" data-emoji="ğŸª–" class="char-icon hover:scale-110 transition p-2 rounded-lg">ğŸª–</button>
                <button data-char="Zizo" data-emoji="âœˆï¸" class="char-icon hover:scale-110 transition p-2 rounded-lg">âœˆï¸</button>
                <button data-char="Souad" data-emoji="ğŸ›¸" class="char-icon hover:scale-110 transition p-2 rounded-lg">ğŸ›¸</button>
                <button data-char="Huda" data-emoji="ğŸš" class="char-icon hover:scale-110 transition p-2 rounded-lg">ğŸš</button>
            </div>
            
            <button id="startButton" class="styled-button bg-green-500 hover:bg-green-600 text-white hidden" disabled>
                Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø·Ù„Ø¹Ø© Ø§Ù„Ø¬ÙˆÙŠØ©!
            </button>
            <p id="selectionMessage" class="text-sm text-yellow-500 mt-2">Ø§Ø®ØªØ± Ù‚Ø§Ø¦Ø¯Ùƒ/Ø·Ø§Ø¦Ø±ØªÙƒ.</p>
        </div>

        <!-- Ø±Ø³Ø§Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© -->
        <div id="gameOverScreen" class="message-box w-11/12 max-w-sm hidden">
            <h2 class="text-4xl font-black mb-4 text-red-500">ØªÙ… ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø·Ø§Ø¦Ø±Ø©! ğŸ’¥</h2>
            <p class="text-xl mb-4 text-gray-200">Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <span id="finalScore" class="text-yellow-400 font-extrabold">0</span></p>
            
            <p class="text-md mb-6 text-yellow-200 border-b border-yellow-700 pb-3">
                âš ï¸ **ØªØ°ÙƒÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ø¯:** Ø§Ù„ØµÙ„Ø§Ø©ØŒ Ø¨Ø± Ø§Ù„ÙˆØ§Ù„Ø¯ÙŠÙ†ØŒ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚Ø±Ø¢Ù†ØŒ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆÙ‚Øª Ù‡ÙŠ Ù…Ù‡Ø§Ù…Ùƒ Ø§Ù„Ø£Ù‡Ù…!
            </p>
            
            <button id="restartButton" class="styled-button bg-blue-500 hover:bg-blue-600 text-white mt-4">
                Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·ÙŠØ±Ø§Ù†
            </button>
        </div>
        
        <!-- Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„Ù…Ø¤Ù‚ØªØ© -->
        <div id="powerupMessage" class="fixed top-4 left-1/2 -translate-x-1/2 bg-yellow-600 text-white p-3 rounded-lg shadow-xl font-bold hidden opacity-0 transition-opacity duration-300">
            ØªÙ… ØªÙØ¹ÙŠÙ„ ØªØ¹Ø²ÙŠØ²!
        </div>
    </div>

    <script>
        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø¹Ø¨Ø©
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationFrameId;
        
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
        const GAME_SPEED = 2.5; 
        const BASE_PLAYER_SIZE = 35; 
        let score = 0;
        let health = 3; 
        let isPlaying = false;
        let playerChar = null; 
        let currentSectorIndex = 0; 
        let isBossActive = false; 
        const SCORE_TO_NEXT_STAGE = 600; 
        let stageTransitionTimer = 0; 

        // Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© (Ø§Ù„Ù…Ø±Ø§Ø­Ù„)
        const LOCATIONS = [
            'Ø§Ù„Ù…Ù‡Ù…Ø© 1: Ø³Ù…Ø§Ø¡ Ù…ØµØ± - Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 2: ØªØ­Ø±ÙŠØ± Ø§Ù„Ø³ÙˆØ¯Ø§Ù† ğŸ‡¸ğŸ‡©',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 3: ØªØ­Ø±ÙŠØ± Ù„ÙŠØ¨ÙŠØ§ ğŸ‡±ğŸ‡¾',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 4: ØªØ­Ø±ÙŠØ± ØªÙˆÙ†Ø³ ğŸ‡¹ğŸ‡³',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 5: ØªØ­Ø±ÙŠØ± Ø§Ù„Ø¬Ø²Ø§Ø¦Ø± ğŸ‡©ğŸ‡¿',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 6: ØªØ­Ø±ÙŠØ± Ø§Ù„Ù…ØºØ±Ø¨ ğŸ‡²ğŸ‡¦',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 7: ØªØ­Ø±ÙŠØ± Ø§Ù„ÙŠÙ…Ù† ğŸ‡¾ğŸ‡ª',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 8: ØªØ­Ø±ÙŠØ± Ø§Ù„Ø¹Ø±Ø§Ù‚ ğŸ‡®ğŸ‡¶',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 9: ØªØ­Ø±ÙŠØ± Ø³ÙˆØ±ÙŠØ§ ğŸ‡¸ğŸ‡¾',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 10: ØªØ­Ø±ÙŠØ± ÙÙ„Ø³Ø·ÙŠÙ† ğŸ‡µğŸ‡¸',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 11: ØªØ­Ø±ÙŠØ± Ø§Ù„Ø£Ø±Ø¯Ù† ğŸ‡¯ğŸ‡´',
            'Ø§Ù„Ù…Ù‡Ù…Ø© 12: ØªØ­Ø±ÙŠØ± Ù„Ø¨Ù†Ø§Ù† ğŸ‡±ğŸ‡§',
        ];
        
        // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø²Ø¹ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„Ø§Ù‚ 
        const BOSS_DEFINITION = { 
            emoji: 'ğŸ›°ï¸', 
            score: 500, 
            baseHealth: 5, 
            size: 70, 
            speed: 0.2 
        };
        
        // Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const charSelection = document.getElementById('char-selection');
        const selectionMessage = document.getElementById('selectionMessage');
        const powerupMessage = document.getElementById('powerupMessage');
        const audioLoadingIndicator = document.getElementById('audioLoading');

        // ÙƒØ§Ø¦Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: BASE_PLAYER_SIZE,
            height: BASE_PLAYER_SIZE,
            emoji: 'ğŸª–',
            shootingCooldown: 0,
            maxCooldown: 5, 
            isInvincible: false,
            invincibleTimer: 0
        };

        let bullets = [];
        let enemies = [];
        let powerups = [];

        // ØªØ¹Ø±ÙŠÙØ§Øª Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ (Ø§Ù„Ù…Ø®Ø§Ø·Ø±)
        const enemyDefinitions = [
            { emoji: 'ğŸ›©ï¸', score: 10, health: 1, color: '#ef4444' }, 
            { emoji: 'ğŸš', score: 20, health: 2, color: '#a855f7' }, 
            { emoji: 'ğŸ“¡', score: 50, health: 3, color: '#facc15' }  
        ];
        
        // ØªØ¹Ø±ÙŠÙØ§Øª Ø§Ù„ØªØ¹Ø²ÙŠØ²Ø§Øª (Ø§Ù„Ù‚ÙŠÙ… ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­)
        const powerupDefinitions = [
            { emoji: 'ğŸ•Œ', effect: 'invincibility', color: '#10b981', message: 'ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµÙ„Ø§Ø© (Ø­Ù…Ø§ÙŠØ© Ø¶Ø¯ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡)' }, 
            { emoji: 'ğŸ“–', effect: 'extraLife', color: '#f59e0b', message: 'Ù†ÙˆØ± Ø§Ù„Ù‚Ø±Ø¢Ù† (Ø­ÙŠØ§Ø© Ø¥Ø¶Ø§ÙÙŠØ©)' },
            { emoji: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', effect: 'clearScreen', color: '#3b82f6', message: 'Ø¨Ø± Ø§Ù„ÙˆØ§Ù„Ø¯ÙŠÙ† (Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Ø´Ø© Ù…Ù† Ø§Ù„Ù…Ø®Ø§Ø·Ø±)' }, 
            { emoji: 'â±ï¸', effect: 'rapidFire', color: '#06b6d4', message: 'Ø§Ù†Ø¶Ø¨Ø§Ø· Ø§Ù„ÙˆÙ‚Øª (Ù†Ø§Ø± ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø³Ø±Ø¹Ø© Ù…Ø¤Ù‚ØªØ§Ù‹)' },
            { emoji: 'ğŸ', effect: 'health', color: '#ef4444', message: 'Ø§Ù„ØºØ°Ø§Ø¡ Ø§Ù„ØµØ­ÙŠ (Ø§Ø³ØªØ¹Ø§Ø¯Ø© ØµØ­Ø©)' },      
            { emoji: 'ğŸ˜´', effect: 'slowMotion', color: '#8b5cf6', message: 'Ø§Ù„Ù†ÙˆÙ… Ø§Ù„ÙƒØ§ÙÙŠ (ØªØ¨Ø·Ø¦Ø© Ø§Ù„Ø²Ù…Ù†)' },         
            { emoji: 'ğŸ§¹', effect: 'scoreMultiplier', color: '#f97316', message: 'Ø§Ù„ØªÙ†Ø¸ÙŠÙ… (Ù…Ø¶Ø§Ø¹Ù Ù†Ù‚Ø§Ø·)' },      
            { emoji: 'ğŸ«‚', effect: 'fireRate', color: '#eab308', message: 'Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ© (Ø²ÙŠØ§Ø¯Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†ÙŠØ±Ø§Ù†)' },        
        ];


        // ------------------------------------------
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØµÙˆØª ÙˆØ§Ù„Ù€ TTS API
        // ------------------------------------------

        // ØªÙ… ØªÙ‡ÙŠØ¦Ø© AudioContext Ù„ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ Ø¯Ø§Ù„Ø© pcmToWav
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Base64 Ø¥Ù„Ù‰ ArrayBuffer.
         * @param {string} base64 - Ø³Ù„Ø³Ù„Ø© Base64.
         * @returns {ArrayBuffer}
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ÙƒØªØ§Ø¨Ø© Ø³Ù„Ø§Ø³Ù„ ÙÙŠ DataView
         */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª PCM Ø®Ø§Ù… Ø¥Ù„Ù‰ Ù…Ù„Ù WAV Blob.
         */
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM

            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk descriptor
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;
            
            // FMT chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; 
            view.setUint16(offset, 1, true); offset += 2; 
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; 
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; 
            view.setUint16(offset, 8 * bytesPerSample, true); offset += 2; 
            
            // DATA chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;

            for (let i = 0; i < pcm16.length; i++, offset += bytesPerSample) {
                view.setInt16(offset, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        /**
         * ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´ØºÙŠÙ„ Ø®Ø·Ø§Ø¨ ØªØ­ÙÙŠØ²ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini TTS API.
         * @param {string} text - Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­ÙˆÙŠÙ„Ù‡ Ø¥Ù„Ù‰ ØµÙˆØª.
         * @param {string} voiceName - Ø§Ø³Ù… Ø§Ù„ØµÙˆØª (Ù…Ø«Ù„ Kore, Puck).
         * @param {string} languageCode - ÙƒÙˆØ¯ Ø§Ù„Ù„ØºØ© (Ù…Ø«Ù„ ar-EG).
         */
        async function generateAndPlayTTS(text, voiceName = "Kore", languageCode = "ar-EG") {
            audioLoadingIndicator.classList.remove('hidden');
            
            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© AudioContext
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        },
                        languageCode: languageCode
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            let audioUrl = null;
            let retries = 0;
            const maxRetries = 3;
            let delay = 1000; 

            while (retries < maxRetries) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) { 
                        retries++;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }

                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000; 

                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        audioUrl = URL.createObjectURL(wavBlob);
                        
                        const audio = new Audio(audioUrl);
                        // Ù†Ø³ØªØ®Ø¯Ù… audio.play() Ø¯Ø§Ø®Ù„ try/catch Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø­Ø¸Ø± Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
                        await audio.play().catch(e => {
                            console.error("Error playing audio (Auto-Play Blocked):", e);
                            showPowerupMessage("âš ï¸ Ø§Ù„Ù…ØªØµÙØ­ Ù…Ù†Ø¹ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹. ÙŠØ±Ø¬Ù‰ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ´ØºÙŠÙ„Ù‡ ÙŠØ¯ÙˆÙŠÙ‹Ø§!");
                        });
                        break; 
                    } else {
                        throw new Error("Invalid audio response structure or missing data.");
                    }
                } catch (error) {
                    console.error("Failed to generate or play TTS:", error);
                    retries = maxRetries; 
                }
            }
            audioLoadingIndicator.classList.add('hidden');
        }


        // ------------------------------------------
        // 1. ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ÙˆØ§Ù„Ø¨Ø¯Ø¡ ÙˆØ§Ù„ØªÙ‚Ø¯Ù…
        // ------------------------------------------

        function initializeGame() {
            setupInputHandlers();
            setupCharacterSelection();
            createSkyBackground(); 
            restartGameVariables();
        }

        function setupCharacterSelection() {
            Array.from(charSelection.children).forEach(button => {
                button.addEventListener('click', (e) => {
                    Array.from(charSelection.children).forEach(b => b.classList.remove('selected'));
                    
                    const charName = e.currentTarget.dataset.char;
                    const charEmoji = e.currentTarget.dataset.emoji;
                    playerChar = charName; 
                    player.emoji = charEmoji;
                    e.currentTarget.classList.add('selected');
                    
                    selectionMessage.textContent = `Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª Ø§Ù„Ù‚Ø§Ø¦Ø¯: ${charName} (${charEmoji})`;
                    startButton.classList.remove('hidden');
                    startButton.disabled = false;
                });
            });

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
        }
        
        // ÙˆØ¸ÙŠÙØ© Ù„ØªØ´ØºÙŠÙ„ ØµÙˆØª Ù†Ù‚Ø±Ø© Ø¨Ø³ÙŠØ· Ù„ØªÙØ¹ÙŠÙ„ AudioContext
        function activateAudioContext() {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log("AudioContext resumed on user interaction.");
                }).catch(e => console.error("Could not resume AudioContext:", e));
            }
        }
        
        // Ø±Ø¨Ø· ØªÙØ¹ÙŠÙ„ AudioContext Ø¨Ø£ÙˆÙ„ ØªÙØ§Ø¹Ù„
        document.body.addEventListener('click', activateAudioContext, { once: true });
        document.body.addEventListener('touchstart', activateAudioContext, { once: true });


        async function startGame() {
            if (!playerChar) return; 
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            isPlaying = true;
            restartGameVariables();
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø²Ø§ÙŠØ§ Ø§Ù„Ø®Ø§ØµØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù‚Ø§Ø¦Ø¯ Ù‡Ùˆ Ø§Ù„Ø³ÙŠØ³ÙŠ
            if (playerChar === 'Ø§Ù„Ø³ÙŠØ³ÙŠ') {
                player.maxCooldown = 4; // Ø¥Ø·Ù„Ø§Ù‚ Ù†Ø§Ø± Ø£Ø³Ø±Ø¹
            }

            applyStageBoosts(); 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animate();
            player.shootingCooldown = 0; 
            
            // 1. Ø§Ù„Ø®Ø·Ø§Ø¨ Ø§Ù„ØªØ­ÙÙŠØ²ÙŠ Ø§Ù„Ø±Ø³Ù…ÙŠ (Ø¨ØµÙˆØª Ø±Ø³Ù…ÙŠ)
            let mainSpeech = "ÙŠØ§ ØµÙ‚Ø± Ø§Ù„Ø¬Ùˆ Ø§Ù„Ù…ØµØ±ÙŠØŒ Ù…Ù‡Ù…ØªÙƒ ØªØ¨Ø¯Ø£ Ø§Ù„Ø¢Ù†! ØªØ°ÙƒØ±ØŒ Ø£Ù†Øª Ø­ÙÙŠØ¯ Ø­Ø¶Ø§Ø±Ø© Ø³Ø¨Ø¹Ø© Ø¢Ù„Ø§Ù Ø³Ù†Ø©. Ø§Ù†Ø·Ù„Ù‚ ÙˆÙ‚Ù„ Ù„Ù„Ø¹Ø§Ù„Ù…: Ù†Ø­Ù† Ø£Ù… Ø§Ù„Ø¯Ù†ÙŠØ§ØŒ ÙˆÙ„Ù† Ù†ØªÙ†Ø§Ø²Ù„ Ø¹Ù† Ø­Ø±ÙŠØªÙ†Ø§!";
            let mainVoice = 'Kore'; // ØµÙˆØª Ø±Ø³Ù…ÙŠ ÙˆØ«Ø§Ø¨Øª
            
            if (playerChar === 'Ø§Ù„Ø³ÙŠØ³ÙŠ') {
                mainSpeech = "ØªØ­ÙŠØ© Ø³ÙŠØ§Ø¯Ø© Ø§Ù„Ù‚Ø§Ø¦Ø¯ Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ù‚ÙˆØ§Øª Ø§Ù„Ù…Ø³Ù„Ø­Ø©. Ø¨Ø§Ø³Ù… Ù…ØµØ± Ø§Ù„Ø¹Ø¸ÙŠÙ…Ø©ØŒ Ø£Ø·Ù„Ù‚ Ø·Ù„Ù‚ØªÙƒ Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù†Ø­Ùˆ Ø§Ù„ØªØ­Ø±ÙŠØ±. Ù„Ù† ØªÙ‡ØªØ² Ø§Ù„Ø£Ø±Ø¶ ØªØ­Øª Ø£Ù‚Ø¯Ø§Ù…Ù†Ø§ ÙˆÙ†Ø­Ù† Ù†Ø¯Ø§ÙØ¹ Ø¹Ù† ÙƒØ±Ø§Ù…Ø© Ø£Ù…ØªÙ†Ø§!";
                mainVoice = 'Orus'; // ØµÙˆØª Ø£ÙƒØ«Ø± Ø­Ø²Ù…Ø§Ù‹
            }
            
            await generateAndPlayTTS(mainSpeech, mainVoice, 'ar-EG');
            
            // 2. Ø§Ù„Ø®Ø·Ø§Ø¨ Ø§Ù„ØªØ­ÙÙŠØ²ÙŠ Ø§Ù„Ø´Ø®ØµÙŠ (Ø¨ØµÙˆØª ÙˆØ¯ÙŠ ÙˆÙ…Ø­ÙØ²)
            let conversationalSpeech = "";
            let friendlyVoice = 'Puck'; // ØµÙˆØª Ù…Ø¨Ù‡Ø¬ ÙˆÙ…Ø­ÙØ²

            if (playerChar === 'Omar') {
                conversationalSpeech = "Ù‡ÙŠØ§ ÙŠØ§ Ø¹Ù…Ø±! Ø£Ù†Øª Ø£Ù…Ù„ Ù…ØµØ± ÙÙŠ Ø§Ù„Ø¬Ùˆ. ØªØ­Ø±Ù‘Ùƒ Ø¨Ø³Ø±Ø¹Ø© ÙˆØ¯Ù‚Ø©!";
            } else if (playerChar === 'Zizo') {
                conversationalSpeech = "Ù‡ÙŠØ§ ÙŠØ§ Ø²ÙŠØ²Ùˆ! Ø£Ø¸Ù‡Ø± Ù„Ù‡Ù… Ù‚ÙˆØ© Ø§Ù„ØµÙ‚ÙˆØ± Ø§Ù„Ù…ØµØ±ÙŠØ©ØŒ Ø¨Ø§Ù„ØªÙˆÙÙŠÙ‚ ÙÙŠ Ø·Ù„Ø¹Ø© Ø§Ù„ØªØ­Ø±ÙŠØ±.";
            }

            if (conversationalSpeech) {
                // Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø·Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
                setTimeout(() => {
                    generateAndPlayTTS(conversationalSpeech, friendlyVoice, 'ar-EG');
                }, 500); 
            }
        }

        function restartGameVariables() {
            score = 0;
            health = 3;
            bullets = [];
            enemies = [];
            powerups = [];
            currentSectorIndex = 0;
            isBossActive = false;
            stageTransitionTimer = 0; 
            document.body.classList.remove('boss-active'); 
            
            player.width = BASE_PLAYER_SIZE;
            player.height = BASE_PLAYER_SIZE;
            player.maxCooldown = 5; // Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
            player.invincibleTimer = 0;
            player.isInvincible = false;
            updateDisplay();
        }

        function gameOver() {
            isPlaying = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            document.getElementById('finalScore').textContent = score;
            gameOverScreen.classList.remove('hidden');
            document.body.classList.remove('boss-active');
            
            // Ø®Ø·Ø§Ø¨ ØµÙˆØªÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
            generateAndPlayTTS("ÙØ´Ù„Øª Ø§Ù„Ù…Ù‡Ù…Ø©! Ù„ÙƒÙ† Ù„Ø§ ØªØ³ØªØ³Ù„Ù…. Ø£Ø¹Ø¯ Ø§Ù„Ø·ÙŠØ±Ø§Ù† ÙˆÙ„Ø§ ØªÙ†Ø³Ù‰ Ù‚ÙŠÙ…Ù†Ø§ Ø§Ù„Ø£ØµÙŠÙ„Ø©.", 'Fenrir', 'ar-EG');
        }

        function advanceStage() {
            currentSectorIndex++;
            isBossActive = false;
            document.body.classList.remove('boss-active'); 
            
            if (currentSectorIndex >= LOCATIONS.length) {
                showPowerupMessage('ğŸ‰ Ø§Ù†ØªØµØ§Ø± ØªØ§Ø±ÙŠØ®ÙŠ! ØªÙ… ØªØ­Ø±ÙŠØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­!');
                currentSectorIndex = LOCATIONS.length - 1; 
                isPlaying = false; 
                setTimeout(() => {
                    const finalMsg = document.getElementById('gameOverScreen');
                    finalMsg.querySelector('h2').textContent = 'Ø§Ù†ØªØµØ§Ø± ØªØ§Ø±ÙŠØ®ÙŠ! ğŸ‰';
                    finalMsg.querySelector('h2').classList.remove('text-red-500');
                    finalMsg.querySelector('h2').classList.add('text-green-500');
                    finalMsg.classList.remove('hidden');
                }, 500);
                 generateAndPlayTTS("ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù†ØµØ± Ø§Ù„ÙƒØ§Ù…Ù„! Ø§Ù„Ø¹Ø±ÙˆØ¨Ø© ØªÙ†ØªØµØ± Ø¨ÙØ¶Ù„ Ù‚ÙŠØ§Ø¯ØªÙƒÙ… Ø§Ù„Ø­ÙƒÙŠÙ…Ø©.", 'Kore', 'ar-EG');
            } else {
                applyStageBoosts();
                const stageSpeech = `Ø¹Ø¸ÙŠÙ…! ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù. Ø§Ù„Ø¢Ù† Ø§Ù†Ø·Ù„Ù‚ Ø¥Ù„Ù‰: ${LOCATIONS[currentSectorIndex].split(':')[1]}`;
                generateAndPlayTTS(stageSpeech, 'Charon', 'ar-EG');
            }
        }

        function applyStageBoosts() {
            let baseCooldown = (playerChar === 'Ø§Ù„Ø³ÙŠØ³ÙŠ') ? 4 : 5;
            player.maxCooldown = Math.max(1, baseCooldown - currentSectorIndex); 
            
            player.width = BASE_PLAYER_SIZE + (currentSectorIndex * 3);
            player.height = BASE_PLAYER_SIZE + (currentSectorIndex * 3);
            stageTransitionTimer = 180; 
            
            showPowerupMessage(`Ø¨Ø¯Ø¡ Ù…Ù‡Ù…Ø©: ${LOCATIONS[currentSectorIndex % LOCATIONS.length]}`);
        }

        function spawnBoss() {
            const size = BOSS_DEFINITION.size;
            const bossHealth = BOSS_DEFINITION.baseHealth + (currentSectorIndex * 1); 
            
            enemies = []; 
            
            enemies.push({
                ...BOSS_DEFINITION,
                maxHealth: bossHealth,
                health: bossHealth,
                x: canvas.width / 2,
                y: -size,
                size: size,
                speedMultiplier: BOSS_DEFINITION.speed, 
                isBoss: true, 
                cannotDie: false 
            });
            isBossActive = true;
            document.body.classList.add('boss-active'); 
            showPowerupMessage('âš ï¸ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙƒØ¨ÙŠØ± Ø¸Ù‡Ø±! Ù‚Ù… Ø¨ØªØ¯Ù…ÙŠØ±Ù‡ Ø¨Ø³Ø±Ø¹Ø© Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù…Ù‡Ù…Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©.');
            generateAndPlayTTS('Ø§Ø­Ø°Ø±ØŒ Ø¸Ù‡Ø± Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙƒØ¨ÙŠØ± ÙÙŠ Ø§Ù„Ø£ÙÙ‚! Ù„Ø§ ØªØªØ±Ø¯Ø¯ ÙÙŠ ØªØ¯Ù…ÙŠØ±Ù‡.', 'Orus', 'ar-EG');
        }

        // ------------------------------------------
        // 2. ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø³Ù…
        // ------------------------------------------

        function drawPlayer() {
            // ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ø¯/Ø§Ù„Ù…Ø±Ø­Ù„Ø©
            let currentSize = player.width;
            if (playerChar === 'Ø§Ù„Ø³ÙŠØ³ÙŠ') {
                currentSize += 5; // Ø­Ø¬Ù… Ø£ÙƒØ¨Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„Ù‚Ø§Ø¦Ø¯ Ø§Ù„Ø£Ø¹Ù„Ù‰
            }
            
            ctx.font = `${currentSize}px sans-serif`;
            ctx.globalAlpha = (player.isInvincible && (Math.floor(Date.now() / 100) % 2)) ? 0.4 : 1; 
            ctx.fillText(player.emoji, player.x - currentSize / 2, player.y + currentSize / 2);
            ctx.globalAlpha = 1;

            if (playerChar) {
                ctx.fillStyle = '#facc15'; 
                ctx.font = '14px Cairo';
                ctx.textAlign = 'center';
                ctx.fillText(playerChar, player.x, player.y + currentSize / 2 + 10); 
                ctx.textAlign = 'start'; 
            }
            
            ctx.font = '20px sans-serif'; 
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‡ªğŸ‡¬', player.x, player.y + currentSize / 2 + 30); 
            ctx.textAlign = 'start'; 
        }

        function drawBullets() {
            ctx.fillStyle = '#ff7f50'; 
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.font = `${enemy.size}px sans-serif`;
                
                if (enemy.cannotDie) {
                    ctx.globalAlpha = (Math.floor(Date.now() / 150) % 2) ? 1 : 0.6; 
                }
                
                ctx.fillText(enemy.emoji, enemy.x - enemy.size / 2, enemy.y + enemy.size / 2);
                ctx.globalAlpha = 1; 

                ctx.font = '18px sans-serif'; 
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ‡®ğŸ‡±', enemy.x, enemy.y + enemy.size / 2 + 20);
                ctx.textAlign = 'start';

                if (!enemy.cannotDie) {
                    if (enemy.isBoss) {
                        const barWidth = 60; 
                        const barHeight = 6;
                        const barX = enemy.x - barWidth / 2;
                        const barY = enemy.y - enemy.size / 2 - 15;
                        const currentHealthWidth = (enemy.health / enemy.maxHealth) * barWidth;

                        ctx.fillStyle = '#444444'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        ctx.fillStyle = '#ff0000'; 
                        ctx.fillRect(barX, barY, currentHealthWidth, barHeight);
                    } else if (enemy.health < enemy.maxHealth) {
                        const healthBarWidth = (enemy.health / enemy.maxHealth) * enemy.size;
                        ctx.fillStyle = enemy.health > 1 ? '#eab308' : '#ef4444';
                        ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2 - 5, healthBarWidth, 3);
                    }
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(pu => {
                ctx.font = `25px sans-serif`;
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, 18, 0, Math.PI * 2);
                ctx.fillStyle = pu.color + '60'; 
                ctx.fill();
                ctx.closePath();

                ctx.fillText(pu.emoji, pu.x - 12.5, pu.y + 12.5);
            });
        }
        
        function drawHUD() {
            ctx.fillStyle = isBossActive ? 'rgba(239, 68, 68, 0.9)' : 'rgba(234, 179, 8, 0.8)'; 
            ctx.font = '20px Cairo';
            const locationText = LOCATIONS[currentSectorIndex % LOCATIONS.length];
            const textWidth = ctx.measureText(locationText).width;
            
            ctx.fillRect(canvas.width - textWidth - 20, canvas.height - 30, textWidth + 20, 25);
            
            ctx.fillStyle = '#0d1117';
            ctx.fillText(locationText, canvas.width - textWidth - 10, canvas.height - 10);
        }

        function drawStageTransition() {
            if (stageTransitionTimer > 0) {
                stageTransitionTimer--;
                
                let alpha = 1;
                if (stageTransitionTimer > 150) { 
                    alpha = (180 - stageTransitionTimer) / 30;
                } else if (stageTransitionTimer < 30) { 
                    alpha = stageTransitionTimer / 30;
                }
                alpha = Math.min(1, Math.max(0, alpha));

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = '45px Cairo'; 
                ctx.textAlign = 'center';
                const locationText = LOCATIONS[currentSectorIndex % LOCATIONS.length];
                ctx.fillText(locationText, canvas.width / 2, canvas.height / 2 + 10);
            }
        }


        function updateDisplay() {
            scoreDisplay.textContent = score;
            healthDisplay.textContent = health;
        }
        
        function showPowerupMessage(msg) {
            powerupMessage.textContent = msg;
            powerupMessage.classList.remove('hidden', 'opacity-0');
            powerupMessage.classList.add('opacity-100');
            
            setTimeout(() => {
                powerupMessage.classList.remove('opacity-100');
                powerupMessage.classList.add('opacity-0');
                setTimeout(() => powerupMessage.classList.add('hidden'), 300);
            }, 1500);
        }

        function createSkyBackground() {
            const background = document.getElementById('sky-background');
            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = `${Math.random() * 2 + 1}px`;
                star.style.height = star.style.width;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.animationDuration = `${10 + Math.random() * 20}s`;
                background.appendChild(star);
            }
        }

        // ------------------------------------------
        // 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ§Øª ÙˆØ§Ù„ÙÙŠØ²ÙŠØ§Ø¡
        // ------------------------------------------

        function updatePlayerState() {
            if (player.shootingCooldown > 0) {
                player.shootingCooldown--;
            }
            if (player.invincibleTimer > 0) {
                player.invincibleTimer--;
                if (player.invincibleTimer === 0) {
                    player.isInvincible = false;
                }
            }
            
            if (!isBossActive && score >= (currentSectorIndex + 1) * SCORE_TO_NEXT_STAGE && currentSectorIndex < LOCATIONS.length) {
                spawnBoss();
            }
        }

        function updateBullets() {
            bullets.forEach(bullet => {
                bullet.y -= 7; 
            });
            bullets = bullets.filter(bullet => bullet.y > 0);
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.y += GAME_SPEED * enemy.speedMultiplier;
                
                if (enemy.isBoss) {
                    if (enemy.y > 100) {
                        enemy.y -= 0.5; 
                    }
                }
            });
            enemies = enemies.filter(enemy => {
                if (enemy.isBoss && enemy.y >= canvas.height - enemy.size) {
                    gameOver();
                    return false;
                }
                return enemy.y < canvas.height + enemy.size;
            });
        }

        function updatePowerups() {
            powerups.forEach(pu => {
                pu.y += GAME_SPEED * 0.5; 
            });
            powerups = powerups.filter(pu => pu.y < canvas.height + 25);
        }

        let enemySpawnTimer = 0;
        let powerupSpawnTimer = 0;

        function spawnObjects() {
            if (isBossActive) return; 

            enemySpawnTimer++;
            if (enemySpawnTimer > Math.max(20, 100 - score / 50)) { 
                spawnEnemy();
                enemySpawnTimer = 0;
            }

            powerupSpawnTimer++;
            if (powerupSpawnTimer > 400) { 
                spawnPowerup();
                powerupSpawnTimer = 0;
            }
        }

        function spawnEnemy() {
            const def = enemyDefinitions[Math.floor(Math.random() * enemyDefinitions.length)];
            const size = 30;
            
            const cannotDie = def.emoji === 'ğŸ›©ï¸' && Math.random() < 0.2; 
            
            enemies.push({
                ...def,
                maxHealth: def.health,
                health: def.health,
                x: Math.random() * (canvas.width - size) + size / 2,
                y: -size,
                size: size,
                speedMultiplier: 1 + Math.random() * 0.5,
                cannotDie: cannotDie 
            });
        }

        function spawnPowerup() {
            const def = powerupDefinitions[Math.floor(Math.random() * powerupDefinitions.length)];
            powerups.push({
                ...def,
                x: Math.random() * (canvas.width - 30) + 15,
                y: -25,
            });
        }

        // ------------------------------------------
        // 4. Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… ÙˆØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª
        // ------------------------------------------

        function fireBullet() {
            if (player.shootingCooldown > 0) return;

            bullets.push({
                x: player.x - 2, 
                y: player.y - player.height / 2,
                width: 4,
                height: 10
            });
            player.shootingCooldown = player.maxCooldown; 
        }

        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                let bulletDestroyed = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (isColliding(bullet, enemy, true)) {
                        bullets.splice(i, 1); 
                        bulletDestroyed = true;
                        
                        if (enemy.cannotDie) {
                            score += 1; 
                        } else {
                            enemy.health--;
                            
                            if (enemy.health <= 0) {
                                score += enemy.score;
                                
                                if (enemy.isBoss) {
                                    advanceStage(); 
                                }
                                enemies.splice(j, 1); 
                            }
                        }
                        break; 
                    }
                }
                if (bulletDestroyed) {
                    i--; 
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (isColliding(player, enemy, false)) {
                    
                    if (!player.isInvincible) {
                        health--; 
                        player.isInvincible = true;
                        player.invincibleTimer = 180; 
                        if (health <= 0) {
                            gameOver();
                        }
                    }
                    
                    if (!enemy.isBoss) {
                        enemies.splice(i, 1); 
                    }
                    
                    updateDisplay();
                }
            }

            for (let i = powerups.length - 1; i >= 0; i--) {
                const pu = powerups[i];
                if (isColliding(player, pu, false)) {
                    applyPowerupEffect(pu);
                    powerups.splice(i, 1); 
                }
            }
        }

        function isColliding(obj1, obj2, isBullet) {
            const obj1W = isBullet ? obj1.width : player.width;
            const obj1H = isBullet ? obj1.height : player.height;
            const obj1X = isBullet ? obj1.x : obj1.x - obj1W / 2;
            const obj1Y = isBullet ? obj1.y : obj1.y - obj1H / 2;

            const obj2W = obj2.size || obj2.width; 
            const obj2H = obj2.size || obj2.height;
            const obj2X = obj2.x - obj2W / 2;
            const obj2Y = obj2.y - obj2H / 2;

            return obj1X < obj2X + obj2W &&
                   obj1X + obj1W > obj2X &&
                   obj1Y < obj2Y + obj2H &&
                   obj1Y + obj1H > obj2Y;
        }

        function applyPowerupEffect(pu) {
            score += 10;
            showPowerupMessage(pu.message);

            switch (pu.effect) {
                case 'invincibility': 
                    player.isInvincible = true;
                    player.invincibleTimer = 300; 
                    break;
                case 'fireRate': 
                    player.maxCooldown = Math.max(1, player.maxCooldown - 1); 
                    break;
                case 'clearScreen': 
                    enemies = enemies.filter(e => e.isBoss); 
                    break;
                case 'health': 
                    health = Math.min(5, health + 1);
                    break;
                case 'slowMotion': 
                    enemies.forEach(e => e.speedMultiplier = e.isBoss ? 0.1 : 0.5);
                    setTimeout(() => { 
                        enemies.forEach(e => e.speedMultiplier = e.isBoss ? BOSS_DEFINITION.speed : (1 + Math.random() * 0.5)); 
                    }, 3000);
                    break;
                case 'scoreMultiplier': 
                    score += 50; 
                    break;
                case 'extraLife': 
                    health = Math.min(5, health + 1);
                    break;
                case 'rapidFire': 
                    player.maxCooldown = Math.max(1, player.maxCooldown - 10);
                    setTimeout(() => { player.maxCooldown = Math.max(1, 5 - currentSectorIndex); }, 4000); 
                    break;
            }
            updateDisplay();
            // Ø®Ø·Ø§Ø¨ ØµÙˆØªÙŠ Ø¹Ù†Ø¯ ØªØ¬Ù…ÙŠØ¹ ØªØ¹Ø²ÙŠØ²
            generateAndPlayTTS(`ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¹Ø²ÙŠØ²: ${pu.message.split('(')[0].trim()}`, 'Puck', 'ar-EG');
        }

        // ------------------------------------------
        // 5. Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Animation Loop)
        // ------------------------------------------

        function animate() {
            if (!isPlaying) {
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updatePlayerState();
            updateBullets();
            updateEnemies();
            updatePowerups();
            spawnObjects();
            
            fireBullet();
            checkCollisions();

            drawBullets();
            drawEnemies();
            drawPowerups();
            drawPlayer();
            drawHUD(); 
            drawStageTransition(); 
            updateDisplay();

            animationFrameId = requestAnimationFrame(animate);
        }

        // ------------------------------------------
        // 6. Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (Ù…Ø§ÙˆØ³ / Ù„Ù…Ø³)
        // ------------------------------------------

        function setupInputHandlers() {
            const handleMove = (e, isTouch) => {
                if (!isPlaying) return;
                e.preventDefault(); 

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (isTouch) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                player.x = clientX - rect.left;
                player.y = clientY - rect.top;

                player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
                player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));
            };

            canvas.addEventListener('touchstart', (e) => handleMove(e, true), { passive: false });
            canvas.addEventListener('touchmove', (e) => handleMove(e, true), { passive: false });
            
            canvas.addEventListener('mousemove', (e) => handleMove(e, false));
        }

    </script>
</body>
</html>

Ø´https://g.co/gemini/share/6ffea59e568c
